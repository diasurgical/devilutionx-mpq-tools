#include "extract_spell_icons.hpp"

#include <cmath>
#include <cstdint>
#include <cstring>
#include <string>

#include <clx2pixels.hpp>
#include <clx_decode.hpp>
#include <pixels2clx.hpp>

namespace devilution_mpq_tools {

namespace {

constexpr uint8_t TransparentColor = 255;

constexpr uint8_t MinBgColor = 192;
constexpr uint8_t MaxBgColor = 206;

struct Borders {
	uint8_t top;
	uint8_t right;
	uint8_t bottom;
	uint8_t left;
};

constexpr bool ShouldRemove(uint8_t fg, uint8_t bg)
{
	if (fg == 144) {
		// A bright yellow pixel on the foreground is never
		// part of the icon.
		return true;
	}
	if (fg < MinBgColor || fg > MaxBgColor) {
		// Out-of-range of background pixels.
		return false;
	}

	// Generated by `gen_extract_spell_icons_color_distances_main.cpp`:
	const auto [a, b] = std::minmax({ fg, bg });
	const auto d = static_cast<unsigned>(b - a);
	if (d <= 5) return true;
	if (d >= 7 && d <= 14) return false;
	if ((a == 196 && b == 202) || (a == 199 && b == 205)) return true;
	return false;
}

void RemoveBackground(uint8_t *pixels, unsigned width, unsigned height,
    Borders borders, const uint8_t *bg)
{
	// Remove top border:
	std::memset(pixels, TransparentColor, static_cast<size_t>(width) * borders.top);

	const unsigned innerWidth = width - borders.left - borders.right;
	const unsigned innerHeight = height - borders.bottom - borders.top;

	// First round: remove borders, diff against the background,
	// remove confidently transparent colors.
	// Unfortunately, this alone is not enough because the backgrounds
	// are all slightly different (looks like noise).
	for (unsigned y = borders.top, yEnd = borders.top + innerHeight; y < yEnd; ++y) {
		// Remove left border:
		std::memset(&pixels[static_cast<size_t>(y * width)],
		    TransparentColor, borders.left);
		for (unsigned x = borders.left, xEnd = borders.left + innerWidth; x < xEnd; ++x) {
			uint8_t &pixel = pixels[y * width + x];
			if (ShouldRemove(pixel, bg[y * width + x]))
				pixel = TransparentColor;
		}
		// Remove right border:
		std::memset(&pixels[y * width + borders.left + innerWidth],
		    TransparentColor, borders.right);
	}
	// Remove bottom border:
	std::memset(&pixels[static_cast<size_t>((borders.top + innerHeight) * width)],
	    TransparentColor, static_cast<size_t>(width) * borders.bottom);
}

} // namespace

std::string ExtractSpellIcons(std::span<const uint8_t> clxData,
    std::vector<uint8_t> &iconBackground, std::vector<uint8_t> &iconsWithoutBackground)
{
	std::vector<uint8_t> pixels;
	const std::optional<dvl_gfx::IoError> clxError = dvl_gfx::Clx2Pixels(clxData, TransparentColor, pixels);
	if (clxError.has_value())
		return "Failed CLX->Pixels conversion: " + clxError->message;

	size_t numSprites = dvl_gfx::GetNumSpritesFromClxList(clxData.data());
	const std::span<const uint8_t> firstSprite = dvl_gfx::GetSpriteDataFromClxList(clxData.data(), 0);
	const unsigned width = dvl_gfx::GetClxSpriteWidth(firstSprite.data());
	const unsigned height = dvl_gfx::GetClxSpriteHeight(firstSprite.data());

	Borders borders;
	const size_t emptySprite = 26;
	if (width == 37 && height == 38) {
		// `spelli2`, the last sprite is unused
		--numSprites;
		borders.left = borders.bottom = 1;
		borders.right = borders.top = 2;
	} else if (width == 56 && height == 56) {
		// `spelicon`, the last 9 sprites are overlays, unused in DevilutionX.
		numSprites -= 9;
		borders.left = borders.bottom = 5;
		borders.right = borders.top = 4;
	} else {
		return "Unsupported icon size";
	}

	dvl_gfx::Pixels2Clx(&pixels[emptySprite * width * height],
	    /*width=*/width, width, /*frameHeight=*/height, /*numFrames=*/1,
	    TransparentColor, iconBackground);

	for (size_t frame = 0; frame < numSprites; ++frame) {
		if (frame == emptySprite)
			continue;
		RemoveBackground(&pixels[frame * width * height], width, height,
		    borders, &pixels[emptySprite * width * height]);
	}
	std::memset(&pixels[emptySprite * width * height], TransparentColor, width * height);

	dvl_gfx::Pixels2Clx(pixels.data(),
	    /*width=*/width, width, /*frameHeight=*/height, numSprites,
	    TransparentColor, iconsWithoutBackground);
	return "";
}

} // namespace devilution_mpq_tools
